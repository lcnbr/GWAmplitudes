<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.1.251">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>kmocimpulse</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
</style>


<script src="_kmocimpulse_files/libs/clipboard/clipboard.min.js"></script>
<script src="_kmocimpulse_files/libs/quarto-html/quarto.js"></script>
<script src="_kmocimpulse_files/libs/quarto-html/popper.min.js"></script>
<script src="_kmocimpulse_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="_kmocimpulse_files/libs/quarto-html/anchor.min.js"></script>
<link href="_kmocimpulse_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="_kmocimpulse_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="_kmocimpulse_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="_kmocimpulse_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="_kmocimpulse_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">



<p>We can now explore the integrands for a specific observable. Consider the change in momentum, or impulse of particle 1. The (?:kmoc) formalisms gives us a way to write this as:</p>
<p><span class="math display">\[\Delta \ct{\emom[1]}=\AAngle{\int \dPsb{\tw}\Exp[\Big]{-\im\tw^\mu b_\mu}\pa[\Big]{\vIntb[\ct{\emom[1]}]+\rIntb[\ct{\emom[1]}]}}  .\]</span></p>
<p>We then have:</p>
<p><span class="math display">\[
\begin{aligned}
\vIntb[\ct{\emom[1]}]&amp;=\hbar^2\im\,  \tm\, \amp{\emom[1],\emom[2] }{ \emom[1]+\hbar \tw,\emom[2]-\hbar \tw}\\
\rIntb[\ct{\emom[1]}]&amp;=\hbar^2\sumint\ddP[2+\abs{X}]{r_1,r_2,r_X}(r_1^\mu-\emom[1]^\mu)\,\ndeltafn[(4)]{\emom[1]+\emom[2]-r_{1}-r_{2}-r_{X}} \\
&amp;\times   \amp{\emom[1], \emom[2] }{ r_{1}, r_{2}, r_{X}} \aamp{\emom[1]+\hbar \tw,\emom[2]-\hbar \tw }{ r_{1}, r_{2}, r_{X}}.
\end{aligned}
\]</span></p>
<p>We can extract <span class="math inline">\(\hbar\)</span> from <span class="math inline">\(\tm\)</span> and from the amplitude. In order to determine the <span class="math inline">\(\hbar\)</span> scaling of <span class="math inline">\(\ampl\)</span> we extract each coupling constant <span class="math inline">\(\kappa\)</span> along with an <span class="math inline">\(\frac{1}{\sqrt{\hbar}}\)</span>, so that quartic vertices yield a factor of <span class="math inline">\(\frac{\coupling^2}{\hbar}\)</span> whereas cubic ones yield <span class="math inline">\(\frac{\kappa}{\sqrt{\hbar}}\)</span><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. If we count the number <span class="math inline">\(V_3\)</span> of all cubic vertices, <span class="math inline">\(V_4\)</span> the number of quartic vertices, and so on, we have that the number of internal lines is <span class="math inline">\(I=\frac{1}{2}(\sum_{d=3}dV_d-E)\)</span>. This is because we have <span class="math inline">\(\sum_{d=3}dV_d\)</span> lines to start with, out of which <span class="math inline">\(E\)</span> are chosen to be external. The remaining <span class="math inline">\((\sum_{d=3}dV_d-E)\)</span> ones are contracted in pairs among themselves to form <span class="math inline">\(I\)</span> internal lines, yielding the factor of <span class="math inline">\(\half\)</span>. In our case we have <span class="math inline">\(E=4+M\)</span> where <span class="math inline">\(M=\abs{X}\)</span> is the number of messenger particles. Using the argument from loop counting we have that the number of loops of our graph <span class="math inline">\(L\)</span> is given by: <span class="math display">\[
\begin{aligned}
        L=I-V+N=&amp;\frac{1}{2}(\sum_{d=3}d\cdot V_d-4-M)-\sum_{d=3}V_d+1\\
=&amp;\frac{1}{2}(\sum_{d=3}(d-2)V_d)-1-\frac{M}{2},
\end{aligned}
\]</span></p>
<p>where <span class="math inline">\(N\)</span> is the number of connected components (<span class="math inline">\(=1\)</span> in our case) . Thus, we see that the amount of extracted <span class="math inline">\(\hbar\)</span>s corresponds directly to the number of loops plus one plus the number of additional messenger particles. <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> We can thus write the amplitude <span class="math inline">\(\ampl\)</span> as a sum over reduced <span class="math inline">\(L\)</span>-loop amplitudes <span class="math inline">\(\redampl[(L)]\)</span>:</p>
<p><span class="math display">\[\amp{\emom[1],\emom[2]}{ r_1,r_2,X}=\sum\limits_{L=0}^\infty\pa[\Big]{\frac{\coupling^{2}}{\hbar}}^{(L+1+\frac{\abs{X}}{2})}\redamp[(L)]{\emom[1],\emom[2]}{r_1,r_2,X}.\]</span></p>
<p>Going back to the integrands we have:</p>
<p><span id="eq-impulseIv"><span class="math display">\[
\begin{aligned}
\vIntb[\ct{\emom[1]}]&amp;=\hbar^3\im\,  \tw\, \sum\limits_{L=0}^\infty\pa[\Big]{\frac{\coupling^{2}}{\hbar}}^{(L+1)}\redamp[(L)]{\emom[1],\emom[2]}{\emom[1]+\hbar \tw,\emom[2]-\hbar\tw}\\
&amp;=\im\, \hbar  \tw\, \sum\limits_{L=0}^\infty \coupling^{2(L+1)}{\hbar}^{(1-L)}\redamp[(L)]{\emom[1],\emom[2]}{\emom[1]+\hbar \tw,\emom[2]-\hbar\tw},
\end{aligned}
\tag{1}\]</span></span></p>
<p>as well as the real kernel:[^measurech]</p>
<p><span class="math display">\[
\begin{aligned}
\rIntb[\ct{\emom[1]}]&amp;=\hbar^2\sumint\ddP[\abs {X}]{r_X}\brc[\Big]{\prod\limits_{i=1,2}\dn[4]{w_i}\ndeltafn{2\emom[i] \cdot w_i+w_i^2}\thetafn{\emom[i]^0+w_i^0}} \\
&amp;\times w_1^\mu\,\ndeltafn[(4)]{w_1+w_2+r_{X}}
\\
&amp;\times\amp{\emom[1], \emom[2] }{ \emom[1]+w_{1}, \emom[2]+w_{2}, r_{X}}
\aamp{\emom[1]+\hbar \tw,\emom[2]-\hbar \tw }{ \emom[1]+w_{1}, \emom[2]+w_{2}, r_{X}}\\
\end{aligned}
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
=\hbar^2\sumint&amp;\ddP[\abs {X}]{{r}_X}\brc[\Big]{\prod\limits_{i=1,2}\hbar^3\dn[4]{\bar{w}_i}\ndeltafn{2\emom[i] \cdot \bar{w}_i+\hbar\bar{w}_i^2}\thetafn{\emom[i]^0+\hbar \bar{w}_i^0}} \\
&amp;\times   \hbar \bar{w}_1^\mu\,\hbar^{-4}\ndeltafn[(4)]{\bar{w}_1+\bar{w}_2+\bar{r}_{X}}
\\
&amp;\times \sum\limits_{L=0}^\infty \sum\limits_{L'=0}^\infty\pa[\Big]{\frac{\coupling^{2}}{\hbar}}^{(L+L'+2+\abs{X})}\redamp[(L)]{\emom[1], \emom[2] }{\emom[1]+\hbar\bar{w}_{1}, \emom[2]+\hbar\bar{w}_2, r_{X}} \\
&amp;\times\aredamp[(L')]{\emom[1]+\hbar \tw,\emom[2]-\hbar \tw }{\emom[1]+\hbar\bar{w}_{1}, \emom[2]+\hbar\bar{w}_2, r_{X}}
\end{aligned}
\]</span></p>
<p><span id="eq-impulseIr"><span class="math display">\[
\begin{aligned}
=\sumint&amp;\ddP[\abs {X}]{{r}_X}\brc[\Big]{\prod\limits_{i=1,2}\dn[4]{\bar{w}_i}\ndeltafn{2\emom[i] \cdot \bar{w}_i+\hbar\bar{w}_i^2}\thetafn{\emom[i]^0+\hbar \bar{w}_i^0}} \\
&amp;\times    \hbar\bar{w}_1^\mu\,\ndeltafn[(4)]{\bar{w}_1+\bar{w}_2+\bar{r}_{X}}
\\
&amp;\times\sum\limits_{L=0}^\infty \sum\limits_{L'=0}^\infty \coupling^{2(L+L'+2+\abs{X})}{\hbar}^{2-L-L'-\abs{X}}\redamp[(L)]{\emom[1], \emom[2] }{\emom[1]+\hbar\bar{w}_{1}, \emom[2]+\hbar\bar{w}_2, r_{X}} \\
&amp;\times\aredamp[(L')]{\emom[1]+\hbar \tw,\emom[2]-\hbar \tw }{\emom[1]+\hbar\bar{w}_{1}, \emom[2]+\hbar\bar{w}_2, r_{X}}.\\
\end{aligned}
\tag{2}\]</span></span></p>
<p>Schematically we have</p>
<p><span class="math display">\[
\begin{aligned}
\vIntb[\ct{\emom[1]}]&amp;=\sum\limits_{L=0}^\infty \order[{2(L+1)}]{\coupling},\\
\rIntb[\ct{\emom[1]}]&amp;=\sum\limits_{L=0}^\infty \sum\limits_{L'=0}^\infty \order[{2(L+L'+2)+2\abs{X}}]{\coupling}
\end{aligned}
\]</span></p>
<p>The contributions from the virtual kernel are lower order in the coupling <span class="math inline">\(\coupling\)</span> for a given loop order. Both kernels contribute together provided that the following equation is verified:</p>
<p><span id="eq-rvloopmatch"><span class="math display">\[L-1=\tilde{L}+\tilde{L}'+\abs{X}. \tag{3}\]</span></span></p>
<p>where <span class="math inline">\(L\)</span> is the loop count for the virtual kernel, and <span class="math inline">\(\tilde{L}\)</span>,<span class="math inline">\(\tilde{L}'\)</span> and <span class="math inline">\(\abs{X}\)</span> are the real kernel loop count and messenger particle count respectively. Note that for a tree level virtual kernel, the real-kernel match does not exist. The real kernel is only present for <span class="math inline">\(L&gt;0\)</span>. When taking the classical limit we will only retain contributions from graphs that cancel the <span class="math inline">\(\hbar\)</span> divergences in each corresponding kernel. Thus, at the <span class="math inline">\(L\)</span>-loop level, the amplitude in the virtual kernel must cancel with terms of order</p>
<p><span id="eq-hbarvirt"><span class="math display">\[
\hbar^{1-L+O},
\tag{4}\]</span></span></p>
<p>where the <span class="math inline">\(O\)</span> term is the order of <span class="math inline">\(\hbar\)</span> that is present as a result of the observable. In the case of particle 1â€™s momentum, <span class="math inline">\(O=1\)</span>. Similarly, the amplitudes in the real kernel must cancel with:</p>
<p><span id="eq-hbarreal"><span class="math display">\[
\hbar^{2-\tilde{L}+\tilde{L}'-\abs{X}+O}.
\tag{5}\]</span></span></p>
<p>Now we see that the (?:lo) contribution [^expand]to the impulse, which we denote <span class="math inline">\(\Delta \emom[1]^{\mu,(0)}\)</span> can only be from the virtual kernel at tree level. Thus, we have the following equation,</p>
<p><span id="eq-impulseLO"><span class="math display">\[
\Delta \emom[1]^{\mu,(0)}=\AAngle{\int \dPsb{\tw}\Exp[\big]{-\im\tw^\mu b_\mu}\ \vIntb[\ct{\emom[1]}]^{(L=0)}}.
\tag{6}\]</span></span></p>
<p>And the integrand is given by the tree level 4 point amplitude.</p>
<p><span class="math display">\[
\vIntb[\ct{\emom[1]}]^{L=0}=\im\,  \tw^\mu\,  \coupling^{2}{\hbar}^{2}\bar{\mathcal{A}}^{(0)}(\emom[1],\emom[2]\to \emom[1]+\hbar \tw,\emom[2]-\hbar\tw).
\]</span></p>
<p>At (?:nlo), i.e.&nbsp;<span class="math inline">\(\kappa^4\)</span> order, both integrands contribute, as <a href="#eq-rvloopmatch">Equation&nbsp;3</a> can be satisfied for <span class="math inline">\(L=1\)</span>, <span class="math inline">\(L'=0\)</span> and <span class="math inline">\(\abs{X}=2\)</span>. Thus we have the following equation:</p>
<p><span id="eq-impulseNLO"><span class="math display">\[
\Delta \emom[1]^{\mu,(1)}=\AAngle{\int \dPsb{\tw}\Exp[\big]{-\im\tw^\mu b_\mu} \pa[\Big]{\vIntb[\ct{\emom[1]}]^{(L=1)}+\rIntb[\ct{\emom[1]}]^{(L=0,L'=0)}}}.
\tag{7}\]</span></span></p>
<p>The virtual integrand is now given by the 1-loop level amplitude, and the real integrand is given by the square of a the tree level amplitude. This process can go on indefinitely, and is independent of the type of observable and the theory. Here we considered the change of momentum a particle, which for a black hole very far away would be very difficult to measure. However, we can also consider an observable such as the four-momentum of the radiated particles, or more precisely its expectation value. Of course, the operator corresponding to this observable gives zero when acting on the initial momentum states, and only gives a non-zero result when acting on the messenger states. Thus, for this observable only the real integrand, starting with <span class="math inline">\(\abs{X}=1\)</span> will contribute, the (?:lo) contribution being given by what is essentially the unitarity cut of a two loop amplitude. We see that regardless of observable, the objects that are needed are the amplitudes.</p>
<p>For each loop level, many diagrams can contribute, but the classical limit enforces that they must cancel the <span class="math inline">\(\hbar\)</span> orders given by <a href="#eq-hbarreal">Equation&nbsp;5</a> and <a href="#eq-hbarvirt">Equation&nbsp;4</a>. The cancellation order is dependent on the considered observable and filters the contributing diagrams. It can also be reformulated in the language of the method of regions.</p>
<p>To see the whole machinery in action, let us take (?:sqed) as an example theory, that shows the relevant subtleties of the formalism.</p>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>as mentioned in the last section, this is true for gravity and (?:sqed) and we will extend this fact to schematically rescale the vertex coupling by <span class="math inline">\(\hbar^-\Half[d-2]\)</span>, for <span class="math inline">\(d\)</span> the degree of the vertex in question.<a href="#fnref1" class="footnote-back" role="doc-backlink">â†©ï¸Ž</a></p></li>
<li id="fn2"><p>The number of extracted couplings being twice that.<a href="#fnref2" class="footnote-back" role="doc-backlink">â†©ï¸Ž</a></p></li>
</ol>
</section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "î§‹";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
</div> <!-- /content -->



</body></html>